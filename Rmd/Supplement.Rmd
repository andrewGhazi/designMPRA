---
title: "Supplementary Information"
author: "Andrew Ghazi"
date: "6/21/2017"
output: 
  html_document:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      cache = TRUE)
```

## MPRA Activity Noise in Tewhey et al., Cell 2016

Let's visualize the activity standard deviations in each of the transfections in Tewhey et al., Cell 2016. To do this we compute the activity of each barcode in each transfection. Then for every allele in every transfection, we compute the standard deviation of the activities. Then we produce a histogram of the standard deviations in each transfection.

```{r, cache=FALSE}
library(tidyverse)
library(magrittr)
library(parallel)
library(knitr)
library(nortest)
```


```{r}
dir = '/mnt/bigData2/andrew/MPRA/Tewhey/indivTags/'

files = list.files(dir, 
                   pattern = '.expanded$')

getFileDepth = function(file){
  read_tsv(paste0(dir, file),
           col_names = c('allele', 'barcode', 'count')) %>% 
    .$count %>% 
    sum
}

fileDepths = data_frame(src = files,
                        fileDepth = mclapply(src, 
                                             getFileDepth,
                                             mc.cores = 19) %>% unlist)

```

```{r, eval = FALSE}
dnaCounts = map(1:5, ~read_tsv(paste0(dir, files[.x]),
                               col_names = c('allele', 'barcode', 'count')) %>% 
                  mutate(src = files[.x])) %>% 
  reduce(bind_rows) %>% 
  left_join(fileDepths, by = 'src') %>% 
  mutate(depthAdjCount = 1e6*count/fileDepth)

depthAdjDNAmeanCount = dnaCounts %>%  
  group_by(barcode) %>% 
  summarise(allele = allele[1],
            bcMean = mean(depthAdjCount)) %>% 
  ungroup
#grouping together the huge number of barcodes takes a while, so this is saved and loaded

save(depthAdjDNAmeanCount, file = '~/designMPRA/outputs/tewheyDepthAdjDNAcounts.RData')
```
```{r, echo = FALSE, cache = TRUE}
load('~/designMPRA/outputs/tewheyDepthAdjDNAcounts.RData')
```

So to get the DNA normalization factor we simply take the mean of the DNA counts across the DNA transfections. For example:
```{r}
depthAdjDNAmeanCount %>% 
  head %>% 
  kable
```  

So the first barcode for allele `r depthAdjDNAmeanCount$allele[1]` was counted `r depthAdjDNAmeanCount$bcMean[1]` times on average across the plasmid sequencing runs (after adjusting for depth). The depth adjustment is performed as follows:  $$10^6 * \frac{count}{sum\:of\:barcode\:counts\:in\:sequencing\:run}$$  

This normalizes each observed count according to how deeply the replicate was sequenced. 

Tewhey et al., Cell 2016 had five plasmid replicates, so the estimates of these numbers will likely be more precise than the counterparts in Ulirsch et al., Cell 2016 which had only two plasmid replicates. This will in turn make the downstream activity measurements more stable, thus the activity standard deviations in this paper will likely be lower.  

Then we compute the activity levels of each barcode by taking the depth adjusted count from an RNA sequencing run, dividing through the depth adjusted mean count from the DNA runs, then taking the log:

```{r, fig.width=10, eval = FALSE}
library(parallel)
library(nortest) # for lillie.test()
computeTransfectionStatistics = function(fileNum){
  depthNum = fileDepths %>% filter(src == files[fileNum]) %>% .$fileDepth
  
  rnaCounts = read_tsv(paste0(dir, files[fileNum]), 
                       col_names = c('allele', 'barcode', 'count')) %>% 
    mutate(depthAdjCount = 1e6*count/depthNum)
    
    
  
  alleleStatistics = depthAdjDNAmeanCount %>% 
    left_join(rnaCounts, by = c('allele', 'barcode')) %>% 
    mutate(activity = log(depthAdjCount/bcMean)) %>% 
    group_by(allele) %>% 
    summarise(alleleMean = mean(activity, na.rm = TRUE),
              alleleSD = sd(activity, na.rm = TRUE),
              numBarcodes = sum(!is.na(count)),
              lillieforsP = ifelse(numBarcodes > 4, lillie.test(na.omit(activity))$p.value, NA)) %>% 
    filter(numBarcodes > 1) %>%
    mutate(file = files[fileNum])
   # The filter removes alleles that only had zero or one barcodes show up in
   # the RNA, for which a standard deviation is not meaningful
  
  return(alleleStatistics)
}

transfectionStatistics = mclapply(6:19,
                                  computeTransfectionStatistics,
                                  mc.cores = 14)
  
allTransfectionsStats = transfectionStatistics %>% 
  reduce(bind_rows) %>% 
  mutate(file = gsub('Geuv_90K_', '', file) %>% gsub('.tag.ct.indiv.expanded', '', .)) 
#save(allTransfectionsStats, file = '~/designMPRA/outputs/tewheyAllTransfectionsStats.RData')
```

```{r, fig.width=10, cache=FALSE, eval = TRUE}
load('~/designMPRA/outputs/tewheyAllTransfectionsStats.RData')
allTransfectionsStats %>% 
  ggplot(aes(alleleSD)) +
  geom_histogram(bins = 100) +
  facet_wrap('file') +
  xlab('allele activity standard deviation') +
  ggtitle('Allele activity standard deviation distributions by\ntransfection in Tewhey et al., Cell 2016')
```


There is some variability in the distribution of allele activity standard deviations by transfection, but they are commonly above 1.

## Activity Normality

In the earlier section describing the activity variance in MPRA assays, we also calculated the p-value of a Lilliefors test for each allele. A Lilliefors test is a modified Kolmogorov-Smirnov test that tests if the data come from a normal distribution with unspecified mean and variance. A low p-value from a Lilliefors test suggests that the data come from a non-normal distribution.  

Looking at the distribution of these p-values will tell us how commonly the normality assumption of our t-test holds.

```{r}
allTransfectionsStats %>% 
  na.omit() %>% #we returned NA for alleles with <4 observations
  ggplot(aes(lillieforsP)) + 
  geom_histogram(breaks = seq(0,1,length.out = 30))
```  

While clearly skewed from the $Unif(0,1)$ distribution we would expect from truly normally distributed samples, the fact that the p-values are far from 0 most of the time suggests that a t-test should be reasonable approximation.

Furthermore, t-tests are generally considered robust against violations of the normality assumption.

## Power calculations

## Barcode design <fill out>

We used the DNABarcodes package to design a set of <a large number around 1M IIRC> 12-mers. Then screened these according to the design parameters in Melnikov's protocol.


