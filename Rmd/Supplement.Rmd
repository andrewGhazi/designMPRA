---
title: "Supplementary Information"
author: "Andrew Ghazi"
date: "6/21/2017"
output: 
  html_document:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      cache = TRUE)
```

## MPRA Activity Variance in Tewhey et al., Cell 2016

Let's visualize the activity standard deviations in each of the transfections in Tewhey et al., Cell 2016. To do this we compute the activity of each barcode in each transfection. Then for every allele in every transfection, we compute the standard deviation of the activities. Then we produce a histogram of the standard deviations in each transfection.

```{r, cache=FALSE, message=FALSE}
library(tidyverse)
library(magrittr)
library(parallel)
library(knitr)
library(nortest)
```


```{r}
dir = '/mnt/bigData2/andrew/MPRA/Tewhey/indivTags/'

files = list.files(dir, 
                   pattern = '.expanded$')

getFileDepth = function(file){
  read_tsv(paste0(dir, file),
           col_names = c('allele', 'barcode', 'count')) %>% 
    .$count %>% 
    sum
}

fileDepths = data_frame(src = files,
                        fileDepth = mclapply(src, 
                                             getFileDepth,
                                             mc.cores = 19) %>% unlist)

```

```{r, eval = FALSE}
dnaCounts = map(1:5, ~read_tsv(paste0(dir, files[.x]),
                               col_names = c('allele', 'barcode', 'count')) %>% 
                  mutate(src = files[.x])) %>% 
  reduce(bind_rows) %>% 
  left_join(fileDepths, by = 'src') %>% 
  mutate(depthAdjCount = 1e6*count/fileDepth)

depthAdjDNAmeanCount = dnaCounts %>%  
  group_by(barcode) %>% 
  summarise(allele = allele[1],
            bcMean = mean(depthAdjCount)) %>% 
  ungroup
#grouping together the huge number of barcodes takes a while, so this is saved and loaded

save(depthAdjDNAmeanCount, file = '~/designMPRA/outputs/tewheyDepthAdjDNAcounts.RData')
```
```{r, echo = FALSE, cache = TRUE}
load('~/designMPRA/outputs/tewheyDepthAdjDNAcounts.RData')
```

So to get the DNA normalization factor we simply take the mean of the DNA counts across the DNA transfections. For example:
```{r}
depthAdjDNAmeanCount %>% 
  head %>% 
  kable
```  

So the first barcode for allele `r depthAdjDNAmeanCount$allele[1]` was counted `r depthAdjDNAmeanCount$bcMean[1]` times on average across the plasmid sequencing runs (after adjusting for depth). The depth adjustment is performed as follows:  $$10^6 * \frac{count}{sum\:of\:barcode\:counts\:in\:sequencing\:run}$$  

This normalizes each observed count according to how deeply the replicate was sequenced. 

Tewhey et al., Cell 2016 had five plasmid replicates, so the estimates of these numbers will likely be more precise than the counterparts in Ulirsch et al., Cell 2016 which had only two plasmid replicates. This will in turn make the downstream activity measurements more stable, thus the activity standard deviations in this paper will likely be lower.  

Then we compute the activity levels of each barcode by taking the depth adjusted count from an RNA sequencing run, dividing through the depth adjusted mean count from the DNA runs, then taking the log:

```{r, fig.width=10, eval = FALSE}
library(parallel)
library(nortest) # for lillie.test()
computeTransfectionStatistics = function(fileNum){
  depthNum = fileDepths %>% filter(src == files[fileNum]) %>% .$fileDepth
  
  rnaCounts = read_tsv(paste0(dir, files[fileNum]), 
                       col_names = c('allele', 'barcode', 'count')) %>% 
    mutate(depthAdjCount = 1e6*count/depthNum)
    
    
  
  alleleStatistics = depthAdjDNAmeanCount %>% 
    left_join(rnaCounts, by = c('allele', 'barcode')) %>% 
    mutate(activity = log(depthAdjCount/bcMean)) %>% 
    group_by(allele) %>% 
    summarise(alleleMean = mean(activity, na.rm = TRUE),
              alleleSD = sd(activity, na.rm = TRUE),
              numBarcodes = sum(!is.na(count)),
              lillieforsP = ifelse(numBarcodes > 4, lillie.test(na.omit(activity))$p.value, NA)) %>% 
    filter(numBarcodes > 1) %>%
    mutate(file = files[fileNum])
   # The filter removes alleles that only had zero or one barcodes show up in
   # the RNA, for which a standard deviation is not meaningful
  
  return(alleleStatistics)
}

transfectionStatistics = mclapply(6:19,
                                  computeTransfectionStatistics,
                                  mc.cores = 14)
  
allTransfectionsStats = transfectionStatistics %>% 
  reduce(bind_rows) %>% 
  mutate(file = gsub('Geuv_90K_', '', file) %>% gsub('.tag.ct.indiv.expanded', '', .)) 
#save(allTransfectionsStats, file = '~/designMPRA/outputs/tewheyAllTransfectionsStats.RData')
```

```{r, fig.width=10, cache=FALSE, eval = TRUE}
load('~/designMPRA/outputs/tewheyAllTransfectionsStats.RData')
```

```{r, fig.width = 10}
allTransfectionsStats %>% 
  ggplot(aes(alleleSD)) +
  geom_histogram(bins = 100) +
  facet_wrap('file') +
  xlab('allele activity standard deviation') +
  ggtitle('Allele activity standard deviation distributions by\ntransfection in Tewhey et al., Cell 2016')
```



There is some variability in the distribution of allele activity standard deviations by transfection, but they are commonly above 1.

## Activity Normality Assumption  

The "Power" tab of the application uses a t-test to estimate the power to detect functional variants with given activity variance across a range of transcriptional shifts.

In the earlier section describing the activity variance in MPRA assays, we also calculated the p-value of a Lilliefors test for each allele. A Lilliefors test is a modified Kolmogorov-Smirnov test that tests if the data come from a normal distribution with unspecified mean and variance. A low p-value from a Lilliefors test suggests that the data come from a non-normal distribution.  

Looking at the distribution of these p-values will tell us how commonly the normality assumption of our t-test holds.

```{r, fig.width = 10}
allTransfectionsStats %>% 
  na.omit() %>% #we returned NA for alleles with <4 observations
  ggplot(aes(lillieforsP)) + 
  geom_histogram(breaks = seq(0,1,length.out = 30))
```  

While a subset of the variants from Tewhey et al. clearly skew from the $Unif(0,1)$ distribution we would expect from truly normally distributed samples, the fact that the p-values are far from 0 most of the time suggests that a t-test should usually be provide a reasonable approximation of the true power.

Furthermore, t-tests are generally considered robust against violations of the normality assumption. <find a citation for this>

All of this together suggests that having a t-test underlie our power calculations would be reasonable. Researchers won't know the activity variance their experimental setups will achieve nor the true transcriptional shifts of their variants _a prior_ in any case. The "Power" tab of the application is meant to use a few assumptions in order to provide approximate power estimates that researchers can use as rough guidelines for their experiments.

## Power calculations

The power calculations are done with `pwr.t.test` from the R `pwr` package using the following R code:

```{r, eval = FALSE}
tibble::data_frame(meanDiff = seq(0,5, by = .05),
                   pwr = pwr.t.test(n = input$nbarcode*input$nBlock,
                                    d = meanDiff / input$sigma,
                                    sig.level = input$alpha / input$nsnp)$power)
```

This returns the power to detect a transcriptional shift across a range from zero to five using user inputs on:  
* the number of barcodes per allele  
* the number of transfection replicates  
* the number of variants being tested  
* the variance of activity measurements  

This data frame is then plotted.

## Barcode design <fill out>

We generated the set of all possible DNA 12-mers then screened these according to the design parameters in Melnikov's protocol intended to assure that the barcodes are inert. These involve the following parameters:  
* each nucleotide occurs at least once  
* there are no runs of single nucleotides greater than length 4  
* They do not start with `TCT` (this creates a restriction site with XbaI)  
* they do not match any human miR seed sequences



